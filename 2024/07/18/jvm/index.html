<!DOCTYPE html>
<html lang="en">
  <head>
    

    
<script>!function(){var e=window.matchMedia&&window.matchMedia("(prefers-color-scheme: dark)").matches,t=localStorage.getItem("use-color-scheme")||"auto";("dark"===t||e&&"light"!==t)&&document.documentElement.classList.toggle("dark",!0)}()</script>
    

<meta charset="utf-8" >

<title>jvm</title>
<meta name="keywords" content="jvm, Blog">
<meta name="description" content="JVM的内存结构一.程序计数器：程序计数器是一块内存空间，用来存放线程下一个指令所在位置。在单核cpu中，每一时刻只会有一个线程执行指令，这意味着cpu会频繁切换线程，在线程切换后需要恢复到原来的正确位置，这就需要每个线程都有独立的程序计数">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta property="og:title" content="jvm">
<meta property="og:description" content="JVM的内存结构一.程序计数器：程序计数器是一块内存空间，用来存放线程下一个指令所在位置。在单核cpu中，每一时刻只会有一个线程执行指令，这意味着cpu会频繁切换线程，在线程切换后需要恢复到原来的正确位置，这就需要每个线程都有独立的程序计数">

<link rel="shortcut icon" href="/favicon.ico">
<link rel="stylesheet" href="/style/main.css">

  <meta name="generator" content="Hexo 7.2.0"></head>
  <body>
    <div id="app" class="main">

<div class="site-header-container">
  <div class="site-header">
    <div class="left">
      <a href="http://example.com">
        <img class="avatar" src="/images/avatar.png" alt="logo" width="32px" height="32px">
      </a>
      <a href="http://example.com">
        <h1 class="site-title">Blog</h1>
      </a>
    </div>
    <div class="right">
        <i class="icon menu-switch icon-menu-outline" ></i>
    </div>
  </div>
</div>

<div class="menu-container" style="height: 0;opacity: 0;">
<nav class="menu-list">
  
    
      <a href="/" class="menu purple-link">
        首页
      </a>
    
  
    
      <a href="/tags" class="menu purple-link">
        标签
      </a>
    
  
    
      <a href="/archives" class="menu purple-link">
        归档
      </a>
    
  
    
      <a href="/about" class="menu purple-link">
        关于
      </a>
    
  
</nav>
</div>



  <div class="content-container">
    <div class="post-detail">
      
      <h2 class="post-title">jvm</h2>
      <div class="post-info post-detail-info">
        <span><i class="icon icon-calendar-outline"></i> 2024-07-18</span>
        
      </div>
      <div class="post-content-wrapper">
        <div class="post-content">
          <h3 id="JVM的内存结构"><a href="#JVM的内存结构" class="headerlink" title="JVM的内存结构"></a>JVM的内存结构</h3><p><strong>一.程序计数器：</strong><br>程序计数器是一块内存空间，用来存放线程下一个指令所在位置。<br>在单核cpu中，每一时刻只会有一个线程执行指令，这意味着cpu会频繁切换线程，在线程切换后需要恢复到原来的正确位置，这就需要每个线程都有独立的程序计数器<br><strong>二.虚拟机栈：</strong><br>每个方法在执行的同时会创建一个栈帧来存放方法参数和方法内部局部变量，操作数栈，方法出口等信息，每一个方法从调用到返回的过程就对应一个栈帧在虚拟机栈从入栈到出栈的过程<br><strong>三.本地方法栈：</strong><br>本地方法栈和虚拟机栈类似，区别是虚拟机栈为执行java方法服务，本地方法栈为执行native方法服务，native方法是java调用非java代码的接口<br><strong>四.堆：</strong><br>堆内存是被所有线程共享的一块内存，java创建的对象几乎都存放在堆内存中，堆内存又分为新生代和老年代，新生代是用于存放新创建的对象的区域，老年代用于存放长期存活的对象。垃圾回收机制会对堆内存进行垃圾回收。</p>
<p>新生代通常采用标记复制算法，垃圾回收器采用Serial收集器、Parallel收集器。老年代采用标记-清除或标记-整理算法，垃圾回收器采用Serial Old收集器、Parallel Old收集器、CMS收集器<br><strong>五.方法区：</strong><br>方法区是被所有线程共享的一块内存，用来存放虚拟机加载的类信息，常量，静态变量，编译器编译后的代码等<br><strong>六.运行时常量池：</strong><br>是方法区的一部分，存放编译器生成的各种字面量和符号引用</p>
<h3 id="类加载机制："><a href="#类加载机制：" class="headerlink" title="类加载机制："></a>类加载机制：</h3><p><strong>加载</strong>：查找并加载类的二进制数据。类加载器根据类的全限定名来读取对应的.class文件，并将其转换成方法区的运行时数据结构</p>
<p><strong>验证</strong>：确保被加载的类的正确性。目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求。</p>
<p><strong>准备</strong>：为类的静态变量分配内存，并将其初始化为默认值</p>
<p><strong>解析</strong>：把类中的符号引用转换为直接引用</p>
<p><strong>初始化</strong>：对类的静态变量，静态代码块执行初始化操作</p>
<h3 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h3><p>双亲委派机制是类加载器的一种工作机制，是jvm用来加载类的一种层次结构。</p>
<p>他可以划分为这几个层次：</p>
<p>1.启动类加载器（Bootstrap ClassLoader）：负责加载java的核心类</p>
<p>2.扩展类加载器（Extension ClassLoader）：负责加载JRE扩展目录（jre&#x2F;lib&#x2F;ext）中的类</p>
<p>3.应用程序类加载器（Application ClassLoader）：负责加载应用程序classpath下的类</p>
<p>流程：</p>
<p>1.当一个类加载器收到类加载请求时，它不会自己去尝试加载类，而是先委托给父类加载器加载</p>
<p>2.每个类加载器都按照这种方式递归向上委派，直到请求达到最顶层的启动类加载器</p>
<p>3.只有父类加载器无法加载，子类加载器才会尝试加载该类。</p>
<p>作用：</p>
<p>1.使用这种机制可以防止同一个类被多次加载，确保了类的唯一性</p>
<p>2.可以确保核心Java API不会被恶意类替换，从而提高了Java程序的安全性</p>
<h2 id="死亡对象判断方法"><a href="#死亡对象判断方法" class="headerlink" title="死亡对象判断方法"></a>死亡对象判断方法</h2><h5 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h5><p>给对象中添加一个引用计数器：</p>
<ul>
<li>每当有一个地方引用它，计数器就加 1；</li>
<li>当引用失效，计数器就减 1；</li>
<li>任何时候计数器为 0 的对象就是不可能再被使用的。</li>
</ul>
<h5 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h5><p>这个算法的基本思想就是通过一系列的称为 <strong>“GC Roots”</strong> 的对象作为起点，从这些节点开始向下搜索，节点所走过的路径称为引用链，当一个对象到 GC Roots 没有任何引用链相连的话，则证明此对象是不可用的，需要被回收。</p>
<h2 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h2><p>它负责回收不再使用的对象以释放内存空间，防止内存泄漏</p>
<h3 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h3><ul>
<li>首先标记所有活跃对象，然后清除所有未标记的对象。</li>
<li>缺点是会产生内存碎片，可能影响后续的内存分配效率。</li>
</ul>
<h3 id="标记-复制算法"><a href="#标记-复制算法" class="headerlink" title="标记-复制算法"></a>标记-复制算法</h3><ul>
<li>将存活对象复制到一个新的空间中，然后清除旧空间。</li>
<li>适用于处理新生代的垃圾回收，因为新生代中大部分对象都是短期存活的，复制效率高。</li>
</ul>
<h3 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h3><ul>
<li>首先标记所有活跃对象，然后将它们向一端移动，然后清除端边界外的对象。</li>
<li>适用于老年代的垃圾回收，可以减少碎片化。</li>
</ul>
<h3 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h3><p>当前虚拟机的垃圾收集都采用分代收集算法，根据对象存活周期的不同将内存分为几块。一般将 java 堆分为新生代和老年代，这样我们就可以根据各个年代的特点选择合适的垃圾收集算法。</p>
<p>比如在新生代中，每次收集都会有大量对象死去，所以可以选择”标记-复制“算法，只需要付出少量对象的复制成本就可以完成每次垃圾收集。而老年代的对象存活几率是比较高的，而且没有额外的空间对它进行分配担保，所以我们必须选择“标记-清除”或“标记-整理”算法进行垃圾收集。</p>

        </div>
          
        <div class="top-div">
          <ol class="top-box"><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#JVM%E7%9A%84%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84"><span class="top-box-text">JVM的内存结构</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6%EF%BC%9A"><span class="top-box-text">类加载机制：</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6"><span class="top-box-text">双亲委派机制</span></a></li></ol></li><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#%E6%AD%BB%E4%BA%A1%E5%AF%B9%E8%B1%A1%E5%88%A4%E6%96%AD%E6%96%B9%E6%B3%95"><span class="top-box-text">死亡对象判断方法</span></a></li><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95"><span class="top-box-text">垃圾收集算法</span></a><ol class="top-box-child"><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#%E6%A0%87%E8%AE%B0-%E6%B8%85%E9%99%A4%E7%AE%97%E6%B3%95"><span class="top-box-text">标记-清除算法</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#%E6%A0%87%E8%AE%B0-%E5%A4%8D%E5%88%B6%E7%AE%97%E6%B3%95"><span class="top-box-text">标记-复制算法</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#%E6%A0%87%E8%AE%B0-%E6%95%B4%E7%90%86%E7%AE%97%E6%B3%95"><span class="top-box-text">标记-整理算法</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#%E5%88%86%E4%BB%A3%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95"><span class="top-box-text">分代收集算法</span></a></li></ol>
        </div>
          
      </div>
    </div>

    
      <div class="next-post">
        <a class="purple-link" href="/2024/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">
          <h3 class="post-title">
            下一篇：计算机网络
          </h3>
        </a>
      </div>
    
  </div>










<footer>
<div class="site-footer">
  <div class="social-container">
    
      
        <a aria-label="跳转至github" href="https://github.com/laimtao" target="_blank">
          <i class="icon icon-github"></i>
        </a>
      
    
      
    
      
    
      
    
      
    
  </div>
  
    Powered by <a href="https://hexo.io/" target="_blank">Hexo</a> <a href="https://github.com/f-dong/hexo-theme-minimalism" target="_blank">Theme</a>
  
  
  
  
  
  
</div>
</footer>


      </div>
    </div>
    
<script id="hexo-configurations"> window.theme_config = {"image":{"lazyload_enable":true,"photo_zoom":"simple-lightbox"}}; window.is_post = true; </script>

<script src="/js/main.js"></script>






  </body>
</html>

