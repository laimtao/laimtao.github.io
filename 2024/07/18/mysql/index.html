<!DOCTYPE html>
<html lang="en">
  <head>
    

    
<script>!function(){var e=window.matchMedia&&window.matchMedia("(prefers-color-scheme: dark)").matches,t=localStorage.getItem("use-color-scheme")||"auto";("dark"===t||e&&"light"!==t)&&document.documentElement.classList.toggle("dark",!0)}()</script>
    

<meta charset="utf-8" >

<title>mysql</title>
<meta name="keywords" content="mysql, Blog">
<meta name="description" content="mysql基础：
三大范式：

第一范式：强调的是列的原子性，即数据库表的每一列都是不可分割的原子数据项。
第二范式：要求实体的属性完全依赖于主关键字。所谓完全依赖是指不能存在仅依赖主关键字一部分的属性。
第三范式：任何非主属性不依赖于其它">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta property="og:title" content="mysql">
<meta property="og:description" content="mysql基础：
三大范式：

第一范式：强调的是列的原子性，即数据库表的每一列都是不可分割的原子数据项。
第二范式：要求实体的属性完全依赖于主关键字。所谓完全依赖是指不能存在仅依赖主关键字一部分的属性。
第三范式：任何非主属性不依赖于其它">

<link rel="shortcut icon" href="/favicon.ico">
<link rel="stylesheet" href="/style/main.css">

  <meta name="generator" content="Hexo 7.2.0"></head>
  <body>
    <div id="app" class="main">

<div class="site-header-container">
  <div class="site-header">
    <div class="left">
      <a href="http://example.com">
        <img class="avatar" src="/images/avatar.png" alt="logo" width="32px" height="32px">
      </a>
      <a href="http://example.com">
        <h1 class="site-title">Blog</h1>
      </a>
    </div>
    <div class="right">
        <i class="icon menu-switch icon-menu-outline" ></i>
    </div>
  </div>
</div>

<div class="menu-container" style="height: 0;opacity: 0;">
<nav class="menu-list">
  
    
      <a href="/" class="menu purple-link">
        首页
      </a>
    
  
    
      <a href="/tags" class="menu purple-link">
        标签
      </a>
    
  
    
      <a href="/archives" class="menu purple-link">
        归档
      </a>
    
  
    
      <a href="/about" class="menu purple-link">
        关于
      </a>
    
  
</nav>
</div>



  <div class="content-container">
    <div class="post-detail">
      
      <h2 class="post-title">mysql</h2>
      <div class="post-info post-detail-info">
        <span><i class="icon icon-calendar-outline"></i> 2024-07-18</span>
        
      </div>
      <div class="post-content-wrapper">
        <div class="post-content">
          <p><strong>mysql基础：</strong></p>
<p>三大范式：</p>
<ul>
<li>第一范式：强调的是列的原子性，即数据库表的每一列都是不可分割的原子数据项。</li>
<li>第二范式：要求实体的属性完全依赖于主关键字。所谓完全依赖是指不能存在仅依赖主关键字一部分的属性。</li>
<li>第三范式：任何非主属性不依赖于其它非主属性。</li>
</ul>
<p>内连接：合并两个表，两张表中都有的数据才会显示。<br>外连接：合并两个表，结果包括不匹配的行。如果返回显示左表所有数据和右表中满足where 条件的数据，就是左外连接。如果返回显示右表所有数据和左表中满足where 条件的数据，就是右外连接。</p>
<p>having不能单独使用，只能与group by一起使用，如果过滤条件中使用了聚合函数，必须使用having。</p>
<p><strong>视图：</strong></p>
<p>视图是一种虚拟表，本身是不存储数据的，占用很少的内存空间。<br>作用是简化复杂的查询，通过将复杂的连表操作封装起来，使用户使用简单的select语句就能获取想要的数据</p>
<p>只暴露必要的字段，确保数据的安全性</p>
<p><strong>存储过程：</strong></p>
<p>存储过程能够将复杂的SQL封装在一起，应用程序无须关注存储过程内部复杂的SQL逻辑，只需要简单地调用存储过程。</p>
<p>执行过程：存储过程预先存储在 MySQL 服务器上，需要执行的时候，客户端只需要向服务器端发出调用<br>存储过程的命令，服务器端就可以把预先存储好的这一系列 SQL 语句全部执行。</p>
<p>优点：简化操作，提高了sql语句的重用性，减少了开发工作量</p>
<p>缺点：可移植性差，不适合高并发的场景</p>
<p>相较于函数，存储过程是没有返回值的。</p>
<p><strong>索引：</strong></p>
<p>索引（Index）是帮助MySQL高效获取数据的数据结构。可以简单理解为“排好序的快速查找数据结构”，满足特定查找算法。</p>
<p>常见的索引结构有: B 树， B+树和 Hash。</p>
<p><strong>为什么MySQL 没有使用其作为索引的数据结构呢？</strong></p>
<p>Hash 索引不支持顺序和范围查询</p>
<p>二叉树极端情况下会变成一条链表</p>
<p>平衡二叉树因为要满足左子树和右子树高度差小于等于1，每次都要进行频繁的左旋或右旋，影响性能。又因为每个节点只有两个子节点，数据量大时会导致树的层数很大，查询效率变慢</p>
<h5 id="B-树-B-树："><a href="#B-树-B-树：" class="headerlink" title="B 树&amp; B+树："></a>B 树&amp; B+树：</h5><p><strong>B 树&amp; B+树两者有何异同呢？</strong></p>
<ul>
<li>B 树的所有节点既存指针也存放数据，而 B+树只有叶子节点存放指针和数据，其他内节点只存放 指针。</li>
<li>B 树的叶子节点都是独立的，不适合进行范围查找，因为数据分散在不同的节点上，需要在不同层级的节点上进进出出。B+树的叶子节点通过链表进行连接，这样可以提高范围查询的效率，当执行范围查找时，可以从叶子节点起始位置一直遍历到结束位置，可以很方便得获取任意一段范围。</li>
<li>B 树的检索的过程相当于对每个节点做二分查找，可能还没有到达叶子节点，检索就结束了。而 B+树的检索都是从根节点到叶子节点的过程。</li>
</ul>
<p>优点：</p>
<ul>
<li>提高数据检索的效率，降低数据库的IO成本。</li>
<li>通过创建唯一索引，可以保证数据库表中每一行数据的唯一性</li>
</ul>
<p>缺点：</p>
<ul>
<li>创建索引和维护索引要耗费时间，并且随着数据量的增加，所耗费的时间也会增加。</li>
<li>索引需要使用物理文件存储，也会耗费一定空间。</li>
</ul>
<p><strong>索引类型：</strong><br>1.主键索引 （primary key）：一张表只能有一个主键索引，值不允许为空<br>2.唯一索引（unique）：特点是索引的值必须唯一，允许值为空，确保数据在指定的列不会出现重复<br>3.普通索引 （index）：用的比较多，值可以重复<br>4.全文索引 （full text）：用来查找文本中的关键字</p>
<p>5.联合索引：使用表中的多个字段创建索引，只有在查询条件中使用了创建索引时的第一个字段索引才会被使用</p>
<p><strong>最左前缀匹配原则</strong>：在检索数据时从创建联合索引字段从左到右开始匹配，如果查询条件包含了联合索引最左侧的字段，那么优化器会利用这个字段来过滤数据，直到所有索引字段都被匹配完。如果遇到范围查询，比如&gt;和&lt;，会停止匹配</p>
<p>例如：b &#x3D; 2 如果建立(a,b)顺序的索引，是匹配不到(a,b)索引的；但是如果查询条件是a &#x3D; 1 and b &#x3D; 2或者a&#x3D;1(又或者是b &#x3D; 2 and b &#x3D; 1)就可以，因为优化器会自动调整a,b的顺序。再比如a &#x3D; 1 and b &#x3D; 2 and c &gt; 3 and d &#x3D; 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，因为c字段是一个范围查询，它之后的字段会停止匹配。</p>
<p><strong>哪些情况适合创建索引：</strong></p>
<ul>
<li>字段的数值有唯一性的限制</li>
<li>作为 WHERE 条件的字段</li>
<li>经常 GROUP BY 和 ORDER BY 的字段</li>
<li>多表 JOIN 连接操作时，对用于连接的字段创建索引</li>
</ul>
<p><strong>哪些情况不适合创建索引：</strong></p>
<ul>
<li>在where中使用不到的字段，不要设置索引</li>
<li>数据量小的表最好不要使用索引</li>
<li>避免对经常更新的表创建过多的索引</li>
<li>值比较集中的字段，比如性别字段不要加索引，因为性别只有两种类型，男和女，加索引反而更影响性能</li>
</ul>
<p><strong>索引失效：</strong></p>
<ol>
<li><p>未使用索引字段进行查询</p>
</li>
<li><p>索引字段使用了函数</p>
</li>
<li><p>使用了不等于（!&#x3D; 或 &lt;&gt;）操作符</p>
</li>
<li><p>LIKE 操作符进行的模糊查询，如果通配符放在索引列的前面</p>
</li>
<li><p>使用or连接多个条件时</p>
</li>
</ol>
<p><strong>事务：</strong></p>
<p>事务是逻辑上的一组操作</p>
<p>作用：</p>
<p>可以保证多个对数据库的操作（也就是 SQL 语句）构成一个逻辑上的整体。构成这个逻辑上的整体的这些数据库操作遵循：<strong>要么全部执行成功,要么全部不执行</strong> 。</p>
<p><strong>事务ACID特性：</strong></p>
<ol>
<li><strong>原子性</strong>（<code>Atomicity</code>） ： 事务是最小的执行单位，不允许分割。</li>
<li><strong>一致性</strong>（<code>Consistency</code>）： 执行事务前后，数据保持一致，例如转账业务中，无论事务是否成功，转账者和收款人的总额应该是不变的；</li>
<li><strong>隔离性</strong>（<code>Isolation</code>）： 并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的；</li>
<li><strong>持久性</strong>（<code>Durabilily</code>）： 一个事务被提交之后。它对数据库中数据的改变是永久的，即使数据库发生故障也不应该对其有任何影响。</li>
</ol>
<p><strong>redo log和undo log:</strong></p>
<p>redo log可以用于数据库的恢复和持久性，他记录了数据库中所有已经提交了的增加，修改和删除操作。在数据库系统崩溃后通过redo log可以将数据恢复到最后一次提交的状态</p>
<p>undo log用于实现事务的原子性，他记录了事务中每个修改操作的逆操作，当执行回滚操作时，就会执行undo log里存储的逆操作进行撤销</p>
<p><strong>数据并发问题：</strong></p>
<ol>
<li><p>脏写（ Dirty Write ）<br>对于两个事务A、B，如果事务A 修改了另一个未提交事务B 修改的数据，那就意味着发生了脏写</p>
</li>
<li><p>脏读（ Dirty Read ）<br>对于两个事务A、B，A 读取了已经被 B 更新但还没有被提交的字段。之后若 B 回滚， A 读取的内容就是临时且无效的。</p>
</li>
<li><p>不可重复读（ Non-Repeatable Read ）<br>对于两个事务A、B， A 读取了一个字段且没有提交事务，然后  B 更新了该字段。 之后 A 再次读取同一个字段， 值就不同了。那就意味着发生了不可重复读。</p>
</li>
<li><p>幻读（ Phantom ）<br>对于两个事务A、B,  A 从一个表中读取了一个字段, 然后  B 在该表中插入了一些新的行。 之后, 如果  A 再次读取同一个表, 就会多出几行。那就意味着发生了幻读。</p>
</li>
</ol>
<p><strong>4个隔离级别：</strong></p>
<hr>
<table>
<thead>
<tr>
<th>隔离级别</th>
<th>脏读</th>
<th>不可重复读</th>
<th>幻读</th>
</tr>
</thead>
<tbody><tr>
<td>READ-UNCOMMITTED（读未提交）</td>
<td>√</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>READ-COMMITTED（读已提交）</td>
<td>×</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>REPEATABLE-READ（可重复读）</td>
<td>×</td>
<td>×</td>
<td>√</td>
</tr>
<tr>
<td>SERIALIZABLE（可串行化）</td>
<td>×</td>
<td>×</td>
<td>×</td>
</tr>
</tbody></table>
<p>一个事务与其他事务隔离的程度为隔离级别。（也就是相互之间影响的影响的程度导致隔离级别，影响程度越小，那么就说明隔离级别越大）</p>
<p>MySQL 的隔离级别基于锁和 MVCC 机制共同实现的。</p>
<p>串行化隔离级别，是通过锁来实现的。除了 串行化 隔离级别，其他的隔离级别都是基于 MVCC 实现。</p>
<p>mvvc：<code>多版本并发控制</code>，主要是为了提高数据库的<code>并发性能</code>。同一行数据平时发生读写请求时，会<code>上锁阻塞</code>住。但mvcc用更好的方式去处理读—写请求，做到在发生读—写请求冲突时<code>不用加锁</code>。</p>
<p>mysql默认隔离级别为REPEATABLE-READ（可重复读），oracle只支持 Serializable（串行化）级别和 Read committed（读已提交）两种级别，默认隔离级别为 Read committed（读已提交）。</p>
<p><strong>锁：</strong></p>
<ul>
<li>表锁：锁定整个表，有较大的性能瓶颈。<code>LOCK TABLES</code> 和 <code>UNLOCK TABLES</code> 语句实现</li>
<li>行锁：只锁定被操作的行，适合高并发。主要通过事务控制（如 <code>START TRANSACTION</code> 和 <code>COMMIT</code>）来实现</li>
<li>意向锁：用于表示事务对表中某些行的锁定意图，以避免其他事务进行加锁操作造成冲突</li>
<li>共享锁：共享锁允许多个事务同时读取数据，但不允许修改</li>
<li>排他锁：排他锁只允许一个事务读取和修改数据，其他事务不能读取或修改被锁定的数据</li>
</ul>
<h2 id="为什么查询不要用select"><a href="#为什么查询不要用select" class="headerlink" title="**为什么查询不要用select ***"></a>**为什么查询不要用select ***</h2><ol>
<li>当使用select *时，查询会返回表中所有列的数据。如果表中有很多列，但我们只需要其中的一两列数据，就会造成查询时间增加，影响查询性能</li>
<li>查询的字段不够明确会导致维护困难</li>
</ol>
<h2 id="MySql性能如何分析？"><a href="#MySql性能如何分析？" class="headerlink" title="MySql性能如何分析？"></a>MySql性能如何分析？</h2><ol>
<li><p>慢查询日志</p>
<p>修改mysql配置文件，开启慢查询日志，慢查询日志默认记录运行时长超过10s的sql，可以改成其他时间</p>
</li>
<li><p>explain关键字</p>
<p>将explain加在select前面可以查看查询语句是否用到了索引，其中possible_keys显示可能用到的索引，key是实际用到的索引，我们可以根据这两个字段来判断是否需要添加索引</p>
</li>
</ol>
<h2 id="SQL语句优化有哪些方法？"><a href="#SQL语句优化有哪些方法？" class="headerlink" title="SQL语句优化有哪些方法？"></a>SQL语句优化有哪些方法？</h2><ol>
<li>避免使用 <code>SELECT *</code>，而是明确列出需要的列。这样可以减少查询时间</li>
<li>确保数据库表上的查询字段有适当的索引，使用索引可以大大提高检索的速度</li>
<li>尽可能减少连表查询中的连接数量</li>
<li>尽可能使用连接（JOIN）代替子查询，因为连接通常比子查询更有效率</li>
<li>将多次访问数据库的查询合并为更少的查询，减少数据库连接</li>
</ol>
<h3 id="InnoDB和MyISAM区别"><a href="#InnoDB和MyISAM区别" class="headerlink" title="InnoDB和MyISAM区别"></a>InnoDB和MyISAM区别</h3><ol>
<li><strong>InnoDB</strong> 支持事务，<strong>MyISAM</strong> 不支持事务，它的操作是自动提交的，即每个查询都被视为一个独立的事务。</li>
<li><strong>InnoDB</strong> 支持行级锁，<strong>MyISAM</strong> 只支持表级锁</li>
<li><strong>InnoDB</strong> 支持外键约束，<strong>MyISAM</strong> 不支持外键约束</li>
</ol>

        </div>
          
        <div class="top-div">
          <ol class="top-box"><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%9F%A5%E8%AF%A2%E4%B8%8D%E8%A6%81%E7%94%A8select"><span class="top-box-text">**为什么查询不要用select ***</span></a></li><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#MySql%E6%80%A7%E8%83%BD%E5%A6%82%E4%BD%95%E5%88%86%E6%9E%90%EF%BC%9F"><span class="top-box-text">MySql性能如何分析？</span></a></li><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#SQL%E8%AF%AD%E5%8F%A5%E4%BC%98%E5%8C%96%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B9%E6%B3%95%EF%BC%9F"><span class="top-box-text">SQL语句优化有哪些方法？</span></a><ol class="top-box-child"><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#InnoDB%E5%92%8CMyISAM%E5%8C%BA%E5%88%AB"><span class="top-box-text">InnoDB和MyISAM区别</span></a></li></ol></li></ol>
        </div>
          
      </div>
    </div>

    
      <div class="next-post">
        <a class="purple-link" href="/2024/07/18/redis/">
          <h3 class="post-title">
            下一篇：redis
          </h3>
        </a>
      </div>
    
  </div>










<footer>
<div class="site-footer">
  <div class="social-container">
    
      
        <a aria-label="跳转至github" href="https://github.com/laimtao" target="_blank">
          <i class="icon icon-github"></i>
        </a>
      
    
      
    
      
    
      
    
      
    
  </div>
  
    Powered by <a href="https://hexo.io/" target="_blank">Hexo</a> <a href="https://github.com/f-dong/hexo-theme-minimalism" target="_blank">Theme</a>
  
  
  
  
  
  
</div>
</footer>


      </div>
    </div>
    
<script id="hexo-configurations"> window.theme_config = {"image":{"lazyload_enable":true,"photo_zoom":"simple-lightbox"}}; window.is_post = true; </script>

<script src="/js/main.js"></script>






  </body>
</html>

