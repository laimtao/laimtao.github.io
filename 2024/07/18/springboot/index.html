<!DOCTYPE html>
<html lang="en">
  <head>
    

    
<script>!function(){var e=window.matchMedia&&window.matchMedia("(prefers-color-scheme: dark)").matches,t=localStorage.getItem("use-color-scheme")||"auto";("dark"===t||e&&"light"!==t)&&document.documentElement.classList.toggle("dark",!0)}()</script>
    

<meta charset="utf-8" >

<title>springboot</title>
<meta name="keywords" content="springboot, Blog">
<meta name="description" content="springmvc执行流程：1.用户发送请求，前端控制器dispatchservlet来拦截并接收请求2.dispatchservlet收到请求后调用处理器映射器handlermapping，匹配到与请求对应的handler，也就是cont">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta property="og:title" content="springboot">
<meta property="og:description" content="springmvc执行流程：1.用户发送请求，前端控制器dispatchservlet来拦截并接收请求2.dispatchservlet收到请求后调用处理器映射器handlermapping，匹配到与请求对应的handler，也就是cont">

<link rel="shortcut icon" href="/favicon.ico">
<link rel="stylesheet" href="/style/main.css">

  <meta name="generator" content="Hexo 7.2.0"></head>
  <body>
    <div id="app" class="main">

<div class="site-header-container">
  <div class="site-header">
    <div class="left">
      <a href="http://example.com">
        <img class="avatar" src="/images/avatar.png" alt="logo" width="32px" height="32px">
      </a>
      <a href="http://example.com">
        <h1 class="site-title">Blog</h1>
      </a>
    </div>
    <div class="right">
        <i class="icon menu-switch icon-menu-outline" ></i>
    </div>
  </div>
</div>

<div class="menu-container" style="height: 0;opacity: 0;">
<nav class="menu-list">
  
    
      <a href="/" class="menu purple-link">
        首页
      </a>
    
  
    
      <a href="/tags" class="menu purple-link">
        标签
      </a>
    
  
    
      <a href="/archives" class="menu purple-link">
        归档
      </a>
    
  
    
      <a href="/about" class="menu purple-link">
        关于
      </a>
    
  
</nav>
</div>



  <div class="content-container">
    <div class="post-detail">
      
      <h2 class="post-title">springboot</h2>
      <div class="post-info post-detail-info">
        <span><i class="icon icon-calendar-outline"></i> 2024-07-18</span>
        
      </div>
      <div class="post-content-wrapper">
        <div class="post-content">
          <p><strong>springmvc执行流程：</strong><br>1.用户发送请求，前端控制器dispatchservlet来拦截并接收请求<br>2.dispatchservlet收到请求后调用处理器映射器handlermapping，匹配到与请求对应的handler，也就是controller，并返回一个处理器执行链<br>3.dispatchservlet调用处理器适配器handleradapter，handleradapter会执行handler<br>4.handler执行完后，返回modelandview对象给dispatchservlet，model是返回的数据对象，view是逻辑上的视图<br>5.dispatchservlet调用视图解析器viewresolver，并将modelandview传给他<br>6.视图解析器会将逻辑视图转换为物理视图并返回给dispatchservlet<br>7.dispathservlet会将物理视图渲染并返回给用户</p>
<p><strong>springaop：</strong><br>aop是面向切面编程，是一种思想。将一些重复的，和业务主逻辑不相关的代码抽离出来，如日志记录，统计每个方法的执行时间，可以实现模块解耦，使系统更易于维护<br>aop的组成：<br>1.aspect：切面，切面是由切点和通知构成<br>2.joinpoint：连接点，所有可能触发拦截的点,封装了切面方法的信息<br>3.pointcut：切点，定义aop拦截的规则<br>3.advice：通知，规定了aop执行的时间和执行的方法<br>通知有5种：<br>1.前置通知，@before，通知方法会在目标方法前执行<br>2.后置通知，@after，通知方法会在目标方法后执行<br>3.返回之后通知，@afterreturning，通知方法会在目标方法返回之后执行<br>4.抛异常后通知，@afterthrowing，通知会在目标方法抛出异常后执行<br>5.环绕通知，@around，通知包裹了目标方法，通知方法会在目标方法调用之前和调用之后执行<br>实现原理：<br>基于动态代理，springaop只局限于方法级别的拦截<br>动态代理实现方式：<br>1.jdk动态代理，基于接口的实现方式<br>jdk动态代理是通过实现目标接口的方式来创建代理类的，代理类会实现接口中的所有方法，并在代理类中通过反射来调用目标对象的方法，从而完成代理<br>为什么基于接口：<br>在运行时会生成一个代理类，这个代理类默认继承了proxy类，同时实现了我们传入的接口列表，因为java是单继承的，所以jdk动态代理只能代理接口<br>2.cglib动态代理<br>不基于接口，可代理任意类，所以更加灵活<br>CGLIB动态代理不需要目标类实现接口，它通过继承目标类实现代理<br>被代理类和代理类是继承关系<br>在intercept方法前和方法后可以添加一些额外的操作<br>Spring 5.x中AOP默认依旧使用JDK动态代理<br>SpringBoot 2.x开始使用CGLI</p>
<p><strong>spring循环依赖：</strong><br>两个或两个以上的bean相互持有对方，比如a依赖于b，b依赖于c，c又依赖于a<br>解决方法：<br>1.重写设计项目结构，如将3层变4层<br>2.使用@lazy注解，将其中一个延迟加载<br>3.使用setter注入或字段注入而不是构造函数注入</p>
<p><strong>springbean的生命周期：</strong><br>spring是管理bean对象的工厂，负责对象的创建和销毁，springbean的生命周期就是对象从创建到销毁都过程<br>1.实例化，通过new关键字创建bean的实例<br>2.属性赋值，在实例化后，spring通过依赖注入方式设置设置bean的属性<br>3.初始化，在属性注入完成后，spring会调用bean的初始化方法，执行一些初始化操作，比如建立数据库连接<br>4.使用，bean可以被程序调用，执行功能<br>5.销毁，当bean不再需要时，spring会清除不再使用的bean</p>
<p><strong>spring事务：</strong><br>事务是逻辑上的一组操作，要么都执行，要么都不执行<br>如何保证事务原子性：<br>在异常发生的时候，对已进行的操作进行回滚，在mysql中，恢复机制是通过undo log实现的，所有事务进行的修改都会先记录到这个回滚日志中，然后再执行相关的操作<br><strong>事务管理两种方式：</strong><br>1.编程式事务：通过transcationTemplate手动创建事务，实际很少用<br>2.声明式事务：基于aop实现，常用的是@transcational注解<br><strong>spring事务的传播级别：</strong><br>1.required（默认）：如果当前不存在事务，就新建一个事务。如果存在事务，就加入到当前事务<br>2.supports：如果当前没有事务，则以非事务的方式运行，如果存在事务，就加入到当前事务<br>3.mandatory：如果存在事务，就加入到当前事务，如果不存在事务则报错<br>4.required_new：创建一个新的事务，如果存在事务，就将事务挂起<br>5.not_supported：无论是否存在当前事务，都以非事务的方式运行<br>6.never：不使用事务，如果存在事务就抛出异常<br>7.nested：如果当前事务存在，就运行一个嵌套事务，如果不存在事务就新建一个事务<br><strong>事务失效情况：</strong><br>1.方法是非公有的，@transcational是基于aop的，aop又是基于动态代理的，spring要求被代理方法必须是public的<br>2.方法被final修饰，@transcational是基于aop的，aop又是基于动态代理的，动态代理会帮我们生成代理类，在代理类中实现事务功能，但如果方法被final修饰，就不能在代理类中重写这个方法，自然无法添加事务功能<br>3.在非事务方法中调用同一个类里面的事务方法，这种情况相当于绕过了aop，直接调用了this对象，所以事务失效<br>4.未被spring管理，比如说没有加@service注解，使用spring事务的前提是对象要被spring管理，没被管理自然失效<br>5.多线程调用事务方法，因为两个方法不在同一个线程，获取到的数据库连接不一样，所以是两个事务</p>
<p><strong>springbean作用域：</strong><br>1.singleton 默认值 在spring容器中同一个bean只有一个实例<br>2.prototype 原型的 获取bean对象时每次都会创建一个新的实例<br>3.request 每次请求对于同一个bean只有一个实例<br>4.session 在一次会话中一个bean只有一个实例</p>
<p><strong>spring中的bean为什么是单例的</strong></p>
<p>1.使用单例模式可以避免频繁的创建和销毁对象，提升性能</p>
<p>2.在某些情况下，多个对象要共享一个资源，比如数据库连接池，线程池。使用单例模式可以确保所有对象共享同一份资源</p>
<p>3.如果一个对象要保存一些状态信息，使用单例可以保证状态的一致性</p>
<p>4.单例模式可以保证线程安全，因为单例对象只有一个实例，多线程访问不会有安全问题</p>
<p><strong>springboot自动装配原理：</strong></p>
<p>SpringBoot 在启动时会扫描引用 jar 包中的META-INF&#x2F;spring.factories文件（SpringBoot 2.7），这个文件定义了配置类的全限定类名。SpringBoot会根据这些全限定类名生成一些bean并加载到 Spring 容器中，这样就能使用这个jar包提供的功能了</p>
<p><strong>依赖注入3种方式：</strong><br>（1）基于注解的注入。<br>@autowired:按类型装配bean，如果不匹配再按名称装配<br>@resource:相反<br>（2）构造方法注入。<br>（3）setter注入</p>
<p><strong>Spring用了哪些设计模式？</strong></p>
<p>1）单例模式: 在Spring中定义的bean默认是单例模式。</p>
<p>2）工厂模式：Spring使用工厂模式通过BeanFactory、ApplicationContext创建Bean对象。</p>
<p>3）代理模式：Spring AOP功能的实现是通过代理模式中的动态代理实现的。</p>
<p><strong>resultmap与resulttype的区别</strong></p>
<p>首先这两个都是用来做sql查询结果的映射，不同之处在于：</p>
<p>resultmap是用来做复杂查询结果的映射，当查询结果是一个复杂的结构比如说一个对象套了其他的对象，就可以用resultmap。其中<code>association</code>是用来映射一对一的关系，比如说用户对象里面包含了角色对象。<code>collection</code>是用来映射一对多的关系，比如说user对象里面有一个权限权限集合</p>
<p>resulttype就是简单的将查询出来的结果映射成一个对象或者简单的类型，没有嵌套结构</p>

        </div>
          
        <div class="top-div">
          
        </div>
          
      </div>
    </div>

    
      <div class="next-post">
        <a class="purple-link" href="/2024/07/18/mysql/">
          <h3 class="post-title">
            下一篇：mysql
          </h3>
        </a>
      </div>
    
  </div>










<footer>
<div class="site-footer">
  <div class="social-container">
    
      
        <a aria-label="跳转至github" href="https://github.com/laimtao" target="_blank">
          <i class="icon icon-github"></i>
        </a>
      
    
      
    
      
    
      
    
      
    
  </div>
  
    Powered by <a href="https://hexo.io/" target="_blank">Hexo</a> <a href="https://github.com/f-dong/hexo-theme-minimalism" target="_blank">Theme</a>
  
  
  
  
  
  
</div>
</footer>


      </div>
    </div>
    
<script id="hexo-configurations"> window.theme_config = {"image":{"lazyload_enable":true,"photo_zoom":"simple-lightbox"}}; window.is_post = true; </script>

<script src="/js/main.js"></script>






  </body>
</html>

