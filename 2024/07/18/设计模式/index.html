<!DOCTYPE html>
<html lang="en">
  <head>
    

    
<script>!function(){var e=window.matchMedia&&window.matchMedia("(prefers-color-scheme: dark)").matches,t=localStorage.getItem("use-color-scheme")||"auto";("dark"===t||e&&"light"!==t)&&document.documentElement.classList.toggle("dark",!0)}()</script>
    

<meta charset="utf-8" >

<title>设计模式</title>
<meta name="keywords" content="设计模式, Blog">
<meta name="description" content="1.观察者（Observer）模式的定义：
指多个对象间存在一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。
优点：

降低了目标与观察者之间的耦合关系

目标与观察者之间建立了一套触发机制


缺点">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta property="og:title" content="设计模式">
<meta property="og:description" content="1.观察者（Observer）模式的定义：
指多个对象间存在一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。
优点：

降低了目标与观察者之间的耦合关系

目标与观察者之间建立了一套触发机制


缺点">

<link rel="shortcut icon" href="/favicon.ico">
<link rel="stylesheet" href="/style/main.css">

  <meta name="generator" content="Hexo 7.2.0"></head>
  <body>
    <div id="app" class="main">

<div class="site-header-container">
  <div class="site-header">
    <div class="left">
      <a href="http://example.com">
        <img class="avatar" src="/images/avatar.png" alt="logo" width="32px" height="32px">
      </a>
      <a href="http://example.com">
        <h1 class="site-title">Blog</h1>
      </a>
    </div>
    <div class="right">
        <i class="icon menu-switch icon-menu-outline" ></i>
    </div>
  </div>
</div>

<div class="menu-container" style="height: 0;opacity: 0;">
<nav class="menu-list">
  
    
      <a href="/" class="menu purple-link">
        首页
      </a>
    
  
    
      <a href="/tags" class="menu purple-link">
        标签
      </a>
    
  
    
      <a href="/archives" class="menu purple-link">
        归档
      </a>
    
  
    
      <a href="/about" class="menu purple-link">
        关于
      </a>
    
  
</nav>
</div>



  <div class="content-container">
    <div class="post-detail">
      
      <h2 class="post-title">设计模式</h2>
      <div class="post-info post-detail-info">
        <span><i class="icon icon-calendar-outline"></i> 2024-07-18</span>
        
      </div>
      <div class="post-content-wrapper">
        <div class="post-content">
          <p><strong>1.观察者（Observer）模式</strong>的定义：</p>
<p>指多个对象间存在一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。</p>
<p>优点：</p>
<ul>
<li><p>降低了目标与观察者之间的耦合关系</p>
</li>
<li><p>目标与观察者之间<strong>建立了一套触发机制</strong></p>
</li>
</ul>
<p>缺点：</p>
<ul>
<li><strong>当观察者对象很多时，通知的发布会花费很多时间</strong>，影响程序的效率</li>
</ul>
<p>应用场景：对象间存在一对多关系，一个对象的状态发生改变会影响其他对象。</p>
<p><strong>2.单例（Singleton）模式</strong>的定义：</p>
<p>指<strong>一个类只有一个实例，且该类能自行创建这个实例的一种模式</strong>。</p>
<p>单例模式有 3 个特点：</p>
<ul>
<li><strong>单例类只有一个实例对象</strong>；</li>
<li><strong>该单例对象必须由单例类自行创建</strong>；</li>
<li><strong>单例类对外提供一个访问该单例的全局访问点</strong>；</li>
</ul>
<p>懒汉式：该模式的特点是类加载时没有生成单例，只有当第一次调用 时才去创建这个单例，线程不安全</p>
<p>饿汉式：该模式的特点是<strong>类一旦加载就创建一个单例</strong>，保证在调用 GetInstance 方法之前单例已经存在了，不存在线程安全问题</p>
<p>应用场景：<strong>某类只要求生成一个对象的时候</strong>，<strong>当对象需要被共享的场合</strong>（数据库连接池），<strong>当某类需要频繁实例化，而创建的对象又频繁被销毁的时候</strong>，如多线程的线程池</p>
<p><strong>3.工厂方法（FactoryMethod）模式</strong>的定义：定义一个创建产品对象的工厂接口，将产品对象的实际创建工作放到具体子工厂类当中。</p>
<p>优点：</p>
<ul>
<li>用户只需要知道具体工厂的名称就可得到所要的产品，<strong>无须知道产品的具体创建过程（对创建过程复杂的对象很有作用）</strong>；</li>
<li>在系统<strong>增加新的产品时只需要添加具体产品类和对应的具体工厂类</strong>，无须对原工厂进行任何修改，满足开闭原则；</li>
</ul>
<p>缺点：<strong>每增加一个产品就要增加一个具体产品类和一个对应的具体工厂类，这增加了系统的复杂度</strong>。</p>
<p>应用场景：</p>
<ul>
<li><p>客户只知道创建产品的工厂名，而不知道具体的产品名。如 TCL 电视工厂、海信电视工厂等。</p>
</li>
<li><p>客户不关心创建产品的细节，只关心产品的品牌。</p>
</li>
</ul>
<p><strong>4.抽象工厂（AbstractFactory）模式的定义：是一种为访问类提供一个创建一组相关或相互依赖对象的接口，且访问类无须指定所要产品的具体类就能得到同族的不同等级的产品的模式结构</strong>。抽象工厂模式是<strong>工厂方法模式的升级版本</strong>，工厂方法模式只生产一个等级的产品，而抽象工厂模式<strong>可生产多个等级的产品</strong>（多种产品类型）。</p>
<p>优点：<strong>当增加一个新的产品族时不需要修改原代码</strong></p>
<p>缺点：<strong>当产品族中需要增加一个新的产品时，所有的工厂类都需要进行修改</strong></p>
<p>应用场景：</p>
<ul>
<li><strong>当需要创建的对象是一系列相互关联或相互依赖的产品族时</strong>，如电器工厂中的电视机、洗衣机、空调等。</li>
</ul>
<p><strong>5.代理模式：</strong>访问对象不适合或者不能直接引用目标对象，代理对象作为访问对象和目标对象之间的中介</p>
<p>优点：</p>
<ul>
<li>代理对象可以<strong>扩展目标对象的功能</strong>。</li>
<li>代理模式能将客户端与目标对象分离，在一定程度上<strong>降低了系统的耦合度</strong>。</li>
</ul>
<p>缺点：</p>
<ul>
<li>在客户端和目标对象之间增加一个代理对象，会造成<strong>请求处理速度变慢</strong>。</li>
<li><strong>增加了系统的复杂度</strong>。</li>
</ul>
<p>应用场景：主要用于调用目标对象时，代理附加一些额外的处理功能。</p>
<p>策略模式的主要目的是定义一系列算法或行为，将每一个算法封装起来，并使它们可以互换。客户端代码可以动态选择不同的策略</p>
<p><strong>如何设计一个权限系统：</strong></p>
<p>使用rbac模型来设计，用rbac模型需要在数据库中建5张表，用户表，角色表，权限表，以及两张关联表，用户角色表，角色权限表。他们都是多对多的关系。其中权限是用户可以访问的资源，包括菜单权限，操作权限。菜单权限可以有一级菜单和二级菜单，只要有菜单权限就可以访问页面。操作权限就是页面上面的功能按钮，比如增加，修改和删除按钮。在项目中我们可以自定义一个注解，修饰所有要进行权限控制的接口，在项目启动时将所有接口的路径存到数据库的权限表中。然后再自定义一个过滤器，拦截每次请求获取到用户信息后查出对应的权限列表，看是否与当前请求的接口路径匹配，如果匹配就阻塞，否则放行。</p>

        </div>
          
        <div class="top-div">
          
        </div>
          
      </div>
    </div>

    
      <div class="next-post">
        <a class="purple-link" href="/2024/07/18/springboot/">
          <h3 class="post-title">
            下一篇：springboot
          </h3>
        </a>
      </div>
    
  </div>










<footer>
<div class="site-footer">
  <div class="social-container">
    
      
        <a aria-label="跳转至github" href="https://github.com/laimtao" target="_blank">
          <i class="icon icon-github"></i>
        </a>
      
    
      
    
      
    
      
    
      
    
  </div>
  
    Powered by <a href="https://hexo.io/" target="_blank">Hexo</a> <a href="https://github.com/f-dong/hexo-theme-minimalism" target="_blank">Theme</a>
  
  
  
  
  
  
</div>
</footer>


      </div>
    </div>
    
<script id="hexo-configurations"> window.theme_config = {"image":{"lazyload_enable":true,"photo_zoom":"simple-lightbox"}}; window.is_post = true; </script>

<script src="/js/main.js"></script>






  </body>
</html>

