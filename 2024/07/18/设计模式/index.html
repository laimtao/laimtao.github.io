<!DOCTYPE html>
<html lang="en">
  <head>
    

    
<script>!function(){var e=window.matchMedia&&window.matchMedia("(prefers-color-scheme: dark)").matches,t=localStorage.getItem("use-color-scheme")||"auto";("dark"===t||e&&"light"!==t)&&document.documentElement.classList.toggle("dark",!0)}()</script>
    

<meta charset="utf-8" >

<title>设计模式</title>
<meta name="keywords" content="设计模式, Blog">
<meta name="description" content="1.观察者模式：
指多个对象间存在一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。
优点：

降低了目标与观察者之间的耦合关系

目标与观察者之间建立了一套触发机制


缺点：

当观察者对象很多时，">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta property="og:title" content="设计模式">
<meta property="og:description" content="1.观察者模式：
指多个对象间存在一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。
优点：

降低了目标与观察者之间的耦合关系

目标与观察者之间建立了一套触发机制


缺点：

当观察者对象很多时，">

<link rel="shortcut icon" href="/favicon.ico">
<link rel="stylesheet" href="/style/main.css">

  <meta name="generator" content="Hexo 7.2.0"></head>
  <body>
    <div id="app" class="main">

<div class="site-header-container">
  <div class="site-header">
    <div class="left">
      <a href="http://example.com">
        <img class="avatar" src="/images/avatar.png" alt="logo" width="32px" height="32px">
      </a>
      <a href="http://example.com">
        <h1 class="site-title">Blog</h1>
      </a>
    </div>
    <div class="right">
        <i class="icon menu-switch icon-menu-outline" ></i>
    </div>
  </div>
</div>

<div class="menu-container" style="height: 0;opacity: 0;">
<nav class="menu-list">
  
    
      <a href="/" class="menu purple-link">
        首页
      </a>
    
  
    
      <a href="/tags" class="menu purple-link">
        标签
      </a>
    
  
    
      <a href="/archives" class="menu purple-link">
        归档
      </a>
    
  
    
      <a href="/about" class="menu purple-link">
        关于
      </a>
    
  
</nav>
</div>



  <div class="content-container">
    <div class="post-detail">
      
      <h2 class="post-title">设计模式</h2>
      <div class="post-info post-detail-info">
        <span><i class="icon icon-calendar-outline"></i> 2024-07-18</span>
        
      </div>
      <div class="post-content-wrapper">
        <div class="post-content">
          <p><strong>1.观察者模式</strong>：</p>
<p>指多个对象间存在一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。</p>
<p>优点：</p>
<ul>
<li><p>降低了目标与观察者之间的耦合关系</p>
</li>
<li><p>目标与观察者之间建立了一套触发机制</p>
</li>
</ul>
<p>缺点：</p>
<ul>
<li>当观察者对象很多时，通知的发布会花费很多时间，影响程序的效率</li>
</ul>
<p>应用场景：对象间存在一对多关系，一个对象的状态发生改变会影响其他对象。</p>
<p><strong>2.单例模式</strong>：</p>
<p>指一个类只有一个实例，且该类能自己创建这个实例的一种模式。</p>
<ul>
<li><p>懒汉式：该模式的特点是类加载时没有生成单例，只有当第一次调用 时才去创建这个单例，线程不安全</p>
</li>
<li><p>饿汉式：该模式的特点是类一旦加载就创建一个单例，不存在线程安全问题</p>
</li>
</ul>
<p>应用场景：</p>
<ul>
<li>当一个对象需要被共享的场合（数据库连接池）</li>
<li>当某类需要频繁实例化，而创建的对象又频繁被销毁的时候，如多线程的线程池</li>
</ul>
<p><strong>3.工厂模式</strong>：</p>
<p>工厂模式的主要目的是创建对象，而不暴露对象创建的具体逻辑</p>
<ol>
<li>简单工厂模式：提供一个工厂类，用于创建对象。工厂类根据参数决定创建哪种具体类的实例。</li>
<li>工厂方法模式：定义一个创建对象的接口，但由子类决定实例化哪一个类</li>
<li>抽象工厂模式：在工厂方法模式基础上加了一层，工厂方法模式是根据类型创建产品对象。抽象工厂模式是根据类型创建工厂对象，然后在创建好的工厂再根据产品类型创建对象</li>
</ol>
<p>优点：</p>
<ul>
<li>用户只需要知道具体工厂的名称就可得到所要的产品，无须知道产品的具体创建过程</li>
<li>在系统增加新的产品时只需要添加具体产品类和对应的具体工厂类，无须对原工厂进行任何修改</li>
</ul>
<p>缺点：每增加一个产品就要增加一个具体产品类和一个对应的具体工厂类，这增加了系统的复杂度。</p>
<p>应用场景：</p>
<ul>
<li>当你不知道具体需要哪个类的对象时。</li>
<li>当你希望将对象的创建和使用分开。</li>
</ul>
<p><strong>4.策略模式：</strong></p>
<p>策略模式的主要目的是定义一系列算法，将每一个算法封装起来，并使它们可以互换</p>
<p>例子：</p>
<p>在开发一个支付系统的时候，可以有多种支付方式，如支付宝支付，微信支付。那我们可以定义一个接口，每种支付方式实现这个接口，在调用支付接口的时候选择具体是哪种支付策略</p>
<p><strong>5.代理模式：</strong></p>
<p>当访问对象不适合或者不能直接调用目标对象时，可以创建代理对象作为访问对象和目标对象之间的中介</p>
<p>优点：</p>
<ul>
<li>代理对象可以扩展目标对象的功能。</li>
<li>代理模式能将客户端与目标对象分离，在一定程度上降低了系统的耦合度。</li>
</ul>
<p>缺点：</p>
<ul>
<li>增加了系统的复杂度。</li>
</ul>
<p><strong>6.原型模式：</strong></p>
<p>是一种创建对象的方式，这种模式实现了一个原型接口，这个接口用于创建当前对象的克隆，当创建对象的代价比较大时可以采用这种模式。例如，一个对象需要在一个高代价的数据库操作之后被创建。我们可以缓存该对象，在下一个请求时返回它的克隆，以此来减少数据库调用。</p>
<p><strong>7.责任链模式：</strong></p>
<p>包含了一系列的处理对象，每个处理对象都可以决定自己处理哪些命令，如果当前对象无法处理，就会传递给下一个处理对象。每个处理对象结合在一起就形成了一条链。请求会沿着这条链从头到尾依次执行</p>
<p>例子：</p>
<p>springsecurity的核心机制过滤器链就是用了责任链模式，它里面定义了很多过滤器，将这些过滤器按顺序存到一个数组里面，当请求过来时，会按顺序依次执行每个过滤器，如果一个过滤器放行了，数组指针就会加一，这样直到最后一个过滤器</p>
<p><strong>如何设计一个权限系统：</strong></p>
<p>使用rbac模型来设计，用rbac模型需要在数据库中建5张表，用户表，角色表，权限表，以及两张关联表，用户角色表，角色权限表。他们都是多对多的关系。其中权限是用户可以访问的资源，包括菜单权限，操作权限。菜单权限可以有一级菜单和二级菜单，只要有菜单权限就可以访问页面。操作权限就是页面上面的功能按钮，比如增加，修改和删除按钮。在项目中我们可以自定义一个注解，修饰所有要进行权限控制的接口，在项目启动时将所有接口的路径存到数据库的权限表中。然后再自定义一个过滤器，拦截每次请求获取到用户信息后查出对应的权限列表，看是否与当前请求的接口路径匹配，如果匹配就放行。</p>

        </div>
          
        <div class="top-div">
          
        </div>
          
      </div>
    </div>

    
      <div class="next-post">
        <a class="purple-link" href="/2024/07/18/springboot/">
          <h3 class="post-title">
            下一篇：springboot
          </h3>
        </a>
      </div>
    
  </div>










<footer>
<div class="site-footer">
  <div class="social-container">
    
      
        <a aria-label="跳转至github" href="https://github.com/laimtao" target="_blank">
          <i class="icon icon-github"></i>
        </a>
      
    
      
    
      
    
      
    
      
    
  </div>
  
    Powered by <a href="https://hexo.io/" target="_blank">Hexo</a> <a href="https://github.com/f-dong/hexo-theme-minimalism" target="_blank">Theme</a>
  
  
  
  
  
  
</div>
</footer>


      </div>
    </div>
    
<script id="hexo-configurations"> window.theme_config = {"image":{"lazyload_enable":true,"photo_zoom":"simple-lightbox"}}; window.is_post = true; </script>

<script src="/js/main.js"></script>






  </body>
</html>

